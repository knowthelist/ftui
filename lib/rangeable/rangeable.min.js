const version="0.1.6-ftui",on=(t,i,s)=>{t.addEventListener(i,s,!1)},off=(t,i,s)=>{t.removeEventListener(i,s)},createElement=function(t,i){const s=document.createElement(t);return i&&s.classList.add(i),s},isFunction=function(t){return t&&"function"==typeof t},isDefined=function(t){return void 0!==t},throttle=function(t,i,s){let e;return function(){if(s=s||this,!e)return t.apply(s,arguments),e=!0,setTimeout(function(){e=!1},i)}};class Rangeable{constructor(t,i){this.version="0",this.plugins=["ruler"];const s={type:"single",tooltips:"always",updateThrottle:30,formatTooltip:t=>t,classes:{input:"rangeable-input",container:"rangeable-container",vertical:"rangeable-vertical",progress:"rangeable-progress",handle:"rangeable-handle",track:"rangeable-track",multiple:"rangeable-multiple",disabled:"rangeable-disabled",tooltips:"rangeable-tooltips",tooltip:"rangeable-tooltip",visible:"rangeable-tooltips--visible"}};"string"==typeof t&&(t=document.querySelector(t)),this.input=t,this.config=Object.assign({},s,i),this.mouseAxis={x:"clientX",y:"clientY"},this.trackSize={x:"width",y:"height"},this.trackPos={x:"left",y:"top"},this.lastPos=0,this.double="double"===this.config.type||Array.isArray(this.config.value),this.touch="ontouchstart"in document.documentElement,this.version=version,this.init(),this.onInit()}init(){if(!this.input.rangeable){const t={min:0,max:100,step:1,value:this.input.value};for(const i in t)this.input[i]||(this.input[i]=t[i]),isDefined(this.config[i])&&(this.input[i]=this.config[i]);this.axis=this.config.vertical?"y":"x",this.input.rangeable=this,this.double?(this.input.values=this.config.value?this.config.value:[this.input.min,this.input.max],this.input.defaultValues=this.input.values.slice()):this.input.defaultValue||(this.input.defaultValue=this.input.value),this.render(),this.input.disabled&&this.disable(),this.initialised=!0}}render(){const t=this.config,i=t.classes,s=createElement("div",i.container),e=createElement("div",i.track),n=createElement("div",i.progress);let o=createElement("div",i.handle),a=createElement("div",i.tooltip);if(this.input.tabIndex=-1,this.double){o=[createElement("div",i.handle),createElement("div",i.handle)],a=[];for(let t=0;t<3;t++)a[t]=createElement("div",i.tooltip);o.forEach((i,s)=>{i.index=s,n.appendChild(i),i.appendChild(a[s]),i.tabIndex=1,t.controls&&t.controls[s]&&t.controls[s].locked&&!0===t.controls[s].locked&&(i.locked=!0)}),t.vertical&&n.appendChild(o[0]),n.appendChild(a[2]),s.classList.add(i.multiple)}else n.appendChild(o),o.appendChild(a),o.tabIndex=1,t.controls&&t.controls.locked&&!0===t.controls.locked&&(o.locked=!0);if(s.appendChild(e),t.vertical&&s.classList.add(i.vertical),t.size&&(s.style[this.trackSize[this.axis]]=isNaN(t.size)?t.size:`${t.size}px`),t.tooltips&&(s.classList.add(i.tooltips),"string"==typeof t.tooltips&&"always"===t.tooltips&&s.classList.add(i.visible)),this.nodes={container:s,track:e,progress:n,handle:o,tooltip:a},this.double){this.nodes.buffer=[];const i=createElement("div","rangeable-buffers");this.input.values.forEach((s,n)=>{const o=createElement("div","rangeable-buffer");i.appendChild(o),this.nodes.buffer.push(o),e.appendChild(i),t.controls&&(this.limits=[{},{}],isDefined(t.controls[n].min)&&(this.limits[n].min=t.controls[n].min),isDefined(t.controls[n].max)&&(this.limits[n].max=t.controls[n].max))}),this.setLimits(t.controls)}else{const i=createElement("div","rangeable-buffer");e.appendChild(i),this.nodes.buffer=i,e.appendChild(i),t.controls&&(this.limits={},isDefined(t.controls.min)&&(this.limits.min=t.controls.min),isDefined(t.controls.max)&&(this.limits.max=t.controls.max)),this.setLimits(t.controls)}e.appendChild(n),this.input.parentNode.insertBefore(s,this.input),s.insertBefore(this.input,e),this.input.classList.add(i.input),this.bind(),this.update()}reset(){this.double?this.input.defaultValues.forEach(this.setValue,this):this.setValue(this.input.defaultValue),this.onEnd()}setValueFromPosition(t){const i=this.getLimits(),s=parseFloat(this.input.step),e=this.rects,n=this.touch?t.touches[0][this.mouseAxis[this.axis]]:t[this.mouseAxis[this.axis]],o=n-this.rects.container[this.trackPos[this.axis]],a=e.container[this.trackSize[this.axis]];if("mousedown"===t.type&&(!this.double&&this.nodes.handle.contains(t.target)||this.double&&(this.nodes.handle[0].contains(t.target)||this.nodes.handle[1].contains(t.target))))return!1;const h=this.config.vertical?(a-o)/a*100:o/a*100;let l=h*(i.max-i.min)/100+i.min;if(l=Math.ceil(l/s)*s,n>=this.lastPos&&(l-=s),parseFloat(l)===parseFloat(this.startValue))return!1;let c=!1;this.double&&(c=this.activeHandle.index),l=this.limit(l,c),this.setValue(l,c)}start(t){if(t.preventDefault(),this.startValue=this.getValue(),this.onStart(),this.nodes.container.classList.add("dragging"),this.recalculate(),this.activeHandle=this.getHandle(t),!this.activeHandle)return!1;this.activeHandle.classList.add("active"),this.setValueFromPosition(t),this.touch?(on(document,"touchmove",this.events.move),on(document,"touchend",this.events.stop),on(document,"touchcancel",this.events.stop)):(on(document,"mousemove",this.events.move),on(document,"mouseup",this.events.stop))}move(t){this.setValueFromPosition(t),this.lastPos=this.touch?t.touches[0][this.mouseAxis[this.axis]]:t[this.mouseAxis[this.axis]]}stop(){this.stopValue=this.getValue(),this.nodes.container.classList.remove("dragging"),this.onEnd(),this.activeHandle.classList.remove("active"),this.activeHandle=!1,this.touch?(off(document,"touchmove",this.events.move),off(document,"touchend",this.events.stop),off(document,"touchcancel",this.events.stop)):(off(document,"mousemove",this.events.move),off(document,"mouseup",this.events.stop)),this.startValue!==this.stopValue&&this.input.dispatchEvent(new Event("change")),this.startValue=null}keydown(t){const i=i=>{switch(t.key){case"ArrowRight":case"ArrowUp":this.stepUp(i);break;case"ArrowLeft":case"ArrowDown":this.stepDown(i)}};this.double?this.nodes.handle.forEach(t=>{t===document.activeElement&&i(t.index)}):this.nodes.handle===document.activeElement&&i()}stepUp(t){const i=parseFloat(this.input.step);let s=this.getValue();this.double&&isDefined(t)&&(s=s[t]);const e=this.limit(parseFloat(s)+i,t);this.setValue(e,t)}stepDown(t){const i=parseFloat(this.input.step);let s=this.getValue();this.double&&isDefined(t)&&(s=s[t]);const e=this.limit(parseFloat(s)-i,t);this.setValue(e,t)}limit(t,i){const s=this.input,e=this.getLimits();return t=parseFloat(t),this.double&&isDefined(i)?(!i&&t>s.values[1]?t=s.values[1]:i>0&&t<s.values[0]&&(t=s.values[0]),this.limits&&(i?t>this.limits[1].max?t=this.limits[1].max:t<this.limits[1].min&&(t=this.limits[1].min):t>this.limits[0].max?t=this.limits[0].max:t<this.limits[0].min&&(t=this.limits[0].min))):this.limits&&(t>this.limits.max?t=this.limits.max:t<this.limits.min&&(t=this.limits.min)),t>e.max?t=e.max:t<e.min&&(t=e.min),t=parseFloat(t),t=t.toFixed(this.accuracy),t}recalculate(){let t=[];this.double?this.nodes.handle.forEach((i,s)=>{t[s]=i.getBoundingClientRect()}):t=this.nodes.handle.getBoundingClientRect(),this.rects={handle:t,container:this.nodes.container.getBoundingClientRect()}}update(){this.recalculate(),this.accuracy=0,this.input.step.includes(".")&&(this.accuracy=(this.input.step.split(".")[1]||[]).length);const t=this.getValue(),i=this.getLimits(),s=this.rects.container[this.trackSize[this.axis]],e=(t,e,n)=>{t.style[this.config.vertical?"bottom":"left"]=`${e}px`,t.style[this.trackSize[this.axis]]=`${n/i.max*s-e}px`};this.double?(this.limits&&this.limits.forEach((t,n)=>{e(this.nodes.buffer[n],t.min/i.max*s,t.max)}),this.input.values.forEach((t,i)=>{this.setValue(this.limit(t,i),i)})):(this.limits&&e(this.nodes.buffer,this.limits.min/i.max*s,this.limits.max),this.setValue(this.limit(t)))}getValue(){return this.double?this.input.values:this.input.value}setValue(t,i){const s=this.nodes;if(this.double){if(!isDefined(i))return!1;s.handle=this.activeHandle?this.activeHandle:s.handle[i]}isDefined(t)||(t=this.input.value),t=this.limit(t,i);const e=this.initialised&&(t!==this.input.value||this.nativeEvent),n=this.config.formatTooltip;if(this.double){const e=this.input.values;if(e[i]=t,this.config.tooltips){s.tooltip[i].textContent=n.call(this,t);const o=s.tooltip[0].getBoundingClientRect(),a=s.tooltip[1].getBoundingClientRect(),h=!(o.right<a.left||o.left>a.right||o.bottom<a.top||o.top>a.bottom);s.container.classList.toggle("combined-tooltip",h),h&&(s.tooltip[2].textContent=e[0]===e[1]?n.call(this,e[0]):`${n.call(this,e[0])} - ${n.call(this,e[1])}`)}}else this.input.value=t,s.tooltip.textContent=n.call(this,t);this.setPosition(t,i),e&&(this.onChange(),this.nativeEvent||this.input.dispatchEvent(new Event("input")),this.nativeEvent=!1)}native(){this.nativeEvent=!0,this.setValue()}getLimits(){return{min:parseFloat(this.input.min),max:parseFloat(this.input.max)}}setLimits(t){if(!isDefined(t))return!1;this.limits||(this.limits=t);const i=(t,i)=>{i&&isDefined(i.min)&&(t.min=i.min),i&&isDefined(i.max)&&(t.max=i.max)};this.double?t.forEach((t,s)=>{i(this.limits[s],t)}):i(this.limits,t),this.update()}setPosition(t){let i;if(this.double){const t=this.getPosition(this.input.values[0]),s=this.getPosition(this.input.values[1]);this.nodes.progress.style[this.config.vertical?"bottom":"left"]=`${t}px`,i=s-t}else i=this.getPosition(t);this.nodes.progress.style[this.trackSize[this.axis]]=`${i}px`}getPosition(t){isDefined(t)||(t=this.input.value);const i=this.getLimits();return(t-i.min)/(i.max-i.min)*this.rects.container[this.trackSize[this.axis]]}getHandle(t){if(!this.double)return!this.nodes.handle.locked&&this.nodes.handle;const i=this.rects,s=Math.abs(t[this.mouseAxis[this.axis]]-i.handle[0][this.trackPos[this.axis]]),e=Math.abs(t[this.mouseAxis[this.axis]]-i.handle[1][this.trackPos[this.axis]]);let n=t.target.closest(`.${this.config.classes.handle}`);return n||(n=s>e?this.nodes.handle[1]:this.nodes.handle[0]),!n.locked&&n}enable(){on(this.nodes.container,this.touch?"touchstart":"mousedown",this.events.start),this.double?this.nodes.handle.forEach(t=>t.tabIndex=1):this.nodes.handle.tabIndex=1,this.nodes.container.classList.remove(this.config.classes.disabled),this.input.disabled=!1}disable(){off(this.nodes.container,this.touch?"touchstart":"mousedown",this.events.start),this.double?this.nodes.handle.forEach(t=>t.removeAttribute("tabindex")):this.nodes.handle.removeAttribute("tabindex"),this.nodes.container.classList.add(this.config.classes.disabled),this.input.disabled=!0}bind(){this.events={};const t=["start","move","stop","update","reset","native","keydown"];t.forEach(t=>{this.events[t]=this[t].bind(this)}),this.events.scroll=throttle(this.events.update,this.config.updateThrottle),this.events.resize=throttle(this.events.update,this.config.updateThrottle),on(document,"scroll",this.events.scroll),on(window,"resize",this.events.resize),on(document,"keydown",this.events.keydown),on(this.nodes.container,this.touch?"touchstart":"mousedown",this.events.start),on(this.input,"input",this.events.native),this.input.form&&on(this.input.form,"reset",this.events.reset)}unbind(){off(document,"scroll",this.events.scroll),off(window,"resize",this.events.resize),off(document,"keydown",this.events.keydown),off(this.nodes.container,this.touch?"touchstart":"mousedown",this.events.start),off(this.input,"input",this.events.native),this.input.form&&off(this.input.form,"reset",this.events.reset),this.events=null}destroy(){this.input.rangeable&&(this.unbind(),this.input.classList.remove(this.config.classes.input),this.nodes.container.parentNode.replaceChild(this.input,this.nodes.container),delete this.input.rangeable,this.initialised=!1)}onInit(){isFunction(this.config.onInit)&&this.config.onInit.call(this,this.getValue())}onStart(){isFunction(this.config.onStart)&&this.config.onStart.call(this,this.getValue())}onChange(){isFunction(this.config.onChange)&&this.config.onChange(this.getValue())}onEnd(){isFunction(this.config.onEnd)&&this.config.onEnd.call(this,this.getValue())}}export default Rangeable;